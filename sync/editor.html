<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Editor - MapWarper Bridge</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body { font-family: system-ui, sans-serif; display: flex; flex-direction: column; }
    
    .header {
      padding: 8px 16px;
      background: #333;
      color: white;
      display: flex;
      align-items: center;
      gap: 16px;
      flex-shrink: 0;
    }
    .header.allmaps { background: #9b59b6; }
    .header.mapwarper { background: #e67e22; }
    .header h1 { font-size: 1rem; white-space: nowrap; }
    .header a { color: #fff; text-decoration: none; font-size: 0.85rem; white-space: nowrap; opacity: 0.9; }
    .header a:hover { opacity: 1; }
    
    .copy-section {
      display: flex;
      align-items: center;
      gap: 6px;
      background: rgba(0,0,0,0.2);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.8rem;
    }
    .copy-section label { color: rgba(255,255,255,0.8); }
    .copy-section .count { color: #8f8; margin-right: 4px; }
    
    .btn {
      padding: 3px 8px;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 0.75rem;
      background: rgba(255,255,255,0.2);
      color: white;
    }
    .btn:hover { background: rgba(255,255,255,0.3); }
    .btn-copy { background: rgba(255,255,255,0.3); }
    .btn-copy:hover { background: rgba(255,255,255,0.4); }
    .btn-download { background: #27ae60; }
    .btn-download:hover { background: #2ecc71; }
    .btn-show { background: rgba(0,0,0,0.2); }
    
    .expandable {
      position: relative;
    }
    .expandable-content {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 4px;
      background: #222;
      border: 1px solid #555;
      border-radius: 4px;
      padding: 8px;
      z-index: 100;
      min-width: 300px;
      max-width: 90vw;
      max-height: 50vh;
      overflow: auto;
    }
    .expandable-content.show { display: block; }
    .expandable-content textarea {
      width: 100%;
      font-family: monospace;
      font-size: 0.7rem;
      background: #1a1a1a;
      color: #ddd;
      border: none;
      resize: none;
      overflow: hidden;
      field-sizing: content;
    }
    .expandable-content textarea.nowrap {
      white-space: pre;
    }
    
    #content {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    
    .editor-frame {
      flex: 1;
      border: none;
      width: 100%;
      min-height: 0;
    }
    
    .loading, .error, .center-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      text-align: center;
    }
    .error { background: #f8d7da; color: #721c24; }
    .loading { background: #f0f0f0; color: #666; }
    .center-content { background: #f5f5f5; }
    
    #copy-controls {
      display: flex;
      gap: 12px;
      flex-shrink: 0;
    }
    
    #sync-status {
      margin-left: auto;
      font-size: 0.8rem;
      padding: 4px 10px;
      border-radius: 4px;
      background: rgba(0,0,0,0.2);
    }
    #sync-status.synced { background: #27ae60; }
    #sync-status.needs-update { background: #c0392b; }
    
    .big-link {
      background: #e67e22;
      color: white;
      padding: 16px 32px;
      font-size: 1.1rem;
      text-decoration: none;
      border-radius: 8px;
      margin-top: 1rem;
    }
    .big-link:hover { background: #d35400; }
  </style>
</head>
<body>
  <div class="header" id="header">
    <h1 id="title">üìù Editor</h1>
    <a href="./">‚Üê Home</a>
    <div id="copy-controls"></div>
    <div id="sync-status"></div>
    <button class="btn" id="refresh-btn" onclick="refreshStatus()" style="margin-left:8px;">üîÑ Refresh</button>
  </div>
  <div id="content"></div>

  <script>
    const CONFIG = {
      mapwarperBaseUrl: 'https://mapwarper.net',
      allmapsAnnotationsUrl: 'https://annotations.allmaps.org',
    };
    
    const params = new URLSearchParams(window.location.search);
    const mapId = params.get('map');
    const mode = params.get('mode') || 'allmaps';
    const contentEl = document.getElementById('content');
    const controlsEl = document.getElementById('copy-controls');
    const headerEl = document.getElementById('header');
    const titleEl = document.getElementById('title');
    const syncStatusEl = document.getElementById('sync-status');
    
    // Set up header based on mode
    headerEl.classList.add(mode);
    titleEl.textContent = mode === 'mapwarper' ? 'üìù Sync to MapWarper' : 'üìù Sync to Allmaps';
    document.title = mode === 'mapwarper' ? 'Sync to MapWarper' : 'Sync to Allmaps';
    
    if (!mapId) {
      contentEl.innerHTML = '<div class="error">Missing map ID.<br><br>Usage: ?map={mapId}&mode=allmaps|mapwarper</div>';
    } else {
      contentEl.innerHTML = '<div class="loading">Loading map data...</div>';
      loadMapData(mapId, mode);
    }
    
    async function refreshStatus() {
      syncStatusEl.textContent = 'Checking...';
      syncStatusEl.className = '';
      
      try {
        const iiifUrl = `${window.location.origin}/mapwarper/maps/${mapId}/iiif`;
        const data = await fetchSyncData(mapId, iiifUrl);
        updateStatusAndControls(data, mode, false);
      } catch (error) {
        syncStatusEl.textContent = 'Error checking status';
        syncStatusEl.className = '';
      }
    }
    
    async function fetchSyncData(mapId, iiifUrl) {
      const allmapsUrl = `${CONFIG.allmapsAnnotationsUrl}/?url=${encodeURIComponent(iiifUrl + '/info.json')}`;
      
      const [iiifInfo, gcpsResponse, maskCoords, allmapsAnnotation] = await Promise.all([
        fetch(`${iiifUrl}/info.json`).then(r => r.json()),
        fetch(`${CONFIG.mapwarperBaseUrl}/api/v1/maps/${mapId}/gcps`).then(r => r.json()),
        fetch(`${window.location.origin}/mapwarper/maps/${mapId}/mask.json`)
          .then(r => r.ok ? r.json() : null)
          .then(d => d?.coords || null)
          .catch(() => null),
        fetch(allmapsUrl, { redirect: 'follow' }).then(r => r.ok ? r.json() : null).catch(() => null),
      ]);
      
      const mwGcps = gcpsResponse.data || [];
      const allmapsGcps = allmapsAnnotation ? parseAllmapsGcps(allmapsAnnotation) : [];
      const allmapsMask = allmapsAnnotation ? parseAllmapsMask(allmapsAnnotation) : null;
      
      const gcpsMatch = compareGcps(mwGcps, allmapsGcps);
      const hasMwMask = maskCoords && maskCoords.length >= 3;
      const effectiveMwMask = maskCoords || [[0, 0], [iiifInfo.width, 0], [iiifInfo.width, iiifInfo.height], [0, iiifInfo.height]];
      const masksMatch = compareMasks(effectiveMwMask, allmapsMask, iiifInfo.height);
      
      return { iiifInfo, mwGcps, allmapsGcps, maskCoords, gcpsMatch, masksMatch, hasMwMask, iiifUrl };
    }
    
    function updateStatusAndControls(data, mode, updateContent = true) {
      const { iiifInfo, mwGcps, allmapsGcps, maskCoords, gcpsMatch, masksMatch, hasMwMask, iiifUrl } = data;
      
      if (mode === 'allmaps') {
        updateSyncStatus(mwGcps.length, allmapsGcps.length, gcpsMatch, masksMatch, hasMwMask);
        updateAllmapsControls(mwGcps, maskCoords, iiifInfo.height, gcpsMatch, masksMatch);
        if (updateContent) {
          const editorUrl = `https://editor.allmaps.org/#/georeference?url=${encodeURIComponent(iiifUrl + '/info.json')}`;
          contentEl.innerHTML = `<iframe class="editor-frame" src="${editorUrl}" allow="fullscreen"></iframe>`;
        }
      } else {
        updateMapwarperSyncStatus(allmapsGcps.length, gcpsMatch);
        updateMapwarperControls(allmapsGcps, gcpsMatch);
        if (updateContent) {
          const editorUrl = `${CONFIG.mapwarperBaseUrl}/maps/${mapId}/warp`;
          contentEl.innerHTML = `
            <div class="center-content">
              <p style="color:#666;margin-bottom:0.5rem;">MapWarper cannot be embedded due to security restrictions.</p>
              <a href="${editorUrl}" target="_blank" class="big-link">Open MapWarper Warp Editor ‚Üó</a>
              ${allmapsGcps.length > 0 && !gcpsMatch ? '<p style="color:#888;font-size:0.85rem;margin-top:1.5rem;">Download the CSV above and import it into MapWarper.</p>' : ''}
            </div>
          `;
        }
      }
    }
    
    function updateAllmapsControls(mwGcps, maskCoords, height, gcpsMatch, masksMatch) {
      let controls = '';
      
      if (mwGcps.length > 0 && !gcpsMatch) {
        const gcpsText = mwGcps.map(g => `${g.attributes.x} ${g.attributes.y} ${g.attributes.lon} ${g.attributes.lat}`).join('\n');
        controls += `
          <div class="copy-section expandable">
            <label>MW GCPs:</label>
            <span class="count">${mwGcps.length}</span>
            <button class="btn btn-copy" onclick="copyText('gcps-data')">üìã Copy</button>
            <button class="btn btn-show" onclick="toggleExpand(this)">Show</button>
            <div class="expandable-content">
              <textarea id="gcps-data" class="nowrap" readonly>${gcpsText}</textarea>
            </div>
          </div>
        `;
      }
      
      if (maskCoords && maskCoords.length >= 3 && !masksMatch) {
        const clipText = maskCoords.map(([x, y]) => `${x},${height - y}`).join('\n');
        controls += `
          <div class="copy-section expandable">
            <label>MW Clip:</label>
            <span class="count">${maskCoords.length} pts</span>
            <button class="btn btn-copy" onclick="copyText('mask-data')">üìã Copy</button>
            <button class="btn btn-show" onclick="toggleExpand(this)">Show</button>
            <div class="expandable-content">
              <textarea id="mask-data" class="nowrap" readonly>${clipText}</textarea>
            </div>
          </div>
        `;
      }
      
      controlsEl.innerHTML = controls;
    }
    
    function updateMapwarperSyncStatus(allmapsGcpCount, gcpsMatch) {
      if (allmapsGcpCount === 0) {
        syncStatusEl.textContent = 'No Allmaps GCPs to sync';
        syncStatusEl.className = '';
      } else if (gcpsMatch) {
        syncStatusEl.textContent = '‚úì GCPs already synced';
        syncStatusEl.className = 'synced';
      } else {
        syncStatusEl.textContent = 'GCPs need update';
        syncStatusEl.className = 'needs-update';
      }
    }
    
    function updateMapwarperControls(allmapsGcps, gcpsMatch) {
      let controls = '';
      
      if (allmapsGcps.length > 0 && !gcpsMatch) {
        window.allmapsGcpsData = allmapsGcps;
        const gcpsText = allmapsGcps.map(g => `${g.x},${g.y},${g.lon},${g.lat}`).join('\n');
        controls += `
          <div class="copy-section expandable">
            <label>Allmaps GCPs:</label>
            <span class="count">${allmapsGcps.length}</span>
            <button class="btn btn-download" onclick="downloadCsv('${mapId}')">‚¨áÔ∏è Download CSV</button>
            <button class="btn btn-copy" onclick="copyText('allmaps-gcps-data')">üìã Copy</button>
            <button class="btn btn-show" onclick="toggleExpand(this)">Show</button>
            <div class="expandable-content">
              <textarea id="allmaps-gcps-data" class="nowrap" readonly>${gcpsText}</textarea>
            </div>
          </div>
        `;
      }
      
      controlsEl.innerHTML = controls;
    }
    
    async function loadMapData(mapId, mode) {
      try {
        const iiifUrl = `${window.location.origin}/mapwarper/maps/${mapId}/iiif`;
        const data = await fetchSyncData(mapId, iiifUrl);
        updateStatusAndControls(data, mode, true);
      } catch (error) {
        contentEl.innerHTML = `<div class="error">Error loading map data: ${error.message}</div>`;
      }
    }
    
    function parseAllmapsGcps(annotation) {
      let gcps = [];
      try {
        if (annotation.type === 'AnnotationPage' && annotation.items) {
          annotation.items.forEach(ann => {
            if (ann.body?.features) {
              ann.body.features.forEach(f => {
                gcps.push({
                  x: f.properties?.resourceCoords?.[0],
                  y: f.properties?.resourceCoords?.[1],
                  lon: f.geometry?.coordinates?.[0],
                  lat: f.geometry?.coordinates?.[1],
                });
              });
            }
          });
        } else if (annotation.body?.features) {
          gcps = annotation.body.features.map(f => ({
            x: f.properties?.resourceCoords?.[0],
            y: f.properties?.resourceCoords?.[1],
            lon: f.geometry?.coordinates?.[0],
            lat: f.geometry?.coordinates?.[1],
          }));
        }
      } catch (e) {
        console.error('Error parsing Allmaps GCPs:', e);
      }
      return gcps.filter(g => g.x != null && g.y != null && g.lon != null && g.lat != null);
    }
    
    function parseAllmapsMask(annotation) {
      try {
        let svgValue = null;
        if (annotation.type === 'AnnotationPage' && annotation.items?.[0]) {
          svgValue = annotation.items[0].target?.selector?.value;
        } else if (annotation.target?.selector?.value) {
          svgValue = annotation.target.selector.value;
        }
        
        if (svgValue) {
          // Parse SVG polygon points: <svg...><polygon points="x1,y1 x2,y2 ..." /></svg>
          const match = svgValue.match(/points="([^"]+)"/);
          if (match) {
            const points = match[1].split(' ').map(p => {
              const [x, y] = p.split(',').map(Number);
              return [x, y];
            });
            if (points.length >= 3) {
              return points;
            }
          }
        }
      } catch (e) {
        console.error('Error parsing Allmaps mask:', e);
      }
      return null;
    }
    
    function compareGcps(mwGcps, allmapsGcps) {
      if (mwGcps.length !== allmapsGcps.length) return false;
      if (mwGcps.length === 0) return true;
      
      const tolerance = 0.5;
      const sortedMw = [...mwGcps].sort((a, b) => {
        const ax = a.attributes?.x ?? a.x;
        const bx = b.attributes?.x ?? b.x;
        return ax - bx;
      });
      const sortedAm = [...allmapsGcps].sort((a, b) => a.x - b.x);
      
      for (let i = 0; i < sortedMw.length; i++) {
        const mw = sortedMw[i];
        const am = sortedAm[i];
        const mwX = mw.attributes?.x ?? mw.x;
        const mwY = mw.attributes?.y ?? mw.y;
        const mwLon = mw.attributes?.lon ?? mw.lon;
        const mwLat = mw.attributes?.lat ?? mw.lat;
        
        if (Math.abs(mwX - am.x) > tolerance ||
            Math.abs(mwY - am.y) > tolerance ||
            Math.abs(mwLon - am.lon) > 0.00001 ||
            Math.abs(mwLat - am.lat) > 0.00001) {
          return false;
        }
      }
      return true;
    }
    
    function compareMasks(mwMask, allmapsMask, imageHeight) {
      if (!allmapsMask) return !mwMask || mwMask.length < 3;
      if (!mwMask || mwMask.length < 3) return false;
      if (mwMask.length !== allmapsMask.length) return false;
      
      // Convert MW mask to Allmaps coordinate system (flip Y)
      const mwConverted = mwMask.map(([x, y]) => [x, imageHeight - y]);
      
      const tolerance = 1;
      for (let i = 0; i < mwConverted.length; i++) {
        const mw = mwConverted[i];
        const am = allmapsMask[i];
        if (Math.abs(mw[0] - am[0]) > tolerance || Math.abs(mw[1] - am[1]) > tolerance) {
          return false;
        }
      }
      return true;
    }
    
    function updateSyncStatus(mwGcpCount, allmapsGcpCount, gcpsMatch, masksMatch, hasMwMask) {
      if (mwGcpCount === 0) {
        syncStatusEl.textContent = 'No MW GCPs to sync';
        syncStatusEl.className = '';
        return;
      }
      
      if (allmapsGcpCount === 0) {
        syncStatusEl.textContent = hasMwMask ? 'GCPs & Clip need to be added' : 'GCPs need to be added';
        syncStatusEl.className = 'needs-update';
        return;
      }
      
      if (gcpsMatch && masksMatch) {
        syncStatusEl.textContent = '‚úì All synced';
        syncStatusEl.className = 'synced';
      } else if (!gcpsMatch && !masksMatch && hasMwMask) {
        syncStatusEl.textContent = 'GCPs & Clip need update';
        syncStatusEl.className = 'needs-update';
      } else if (!gcpsMatch) {
        syncStatusEl.textContent = 'GCPs need update';
        syncStatusEl.className = 'needs-update';
      } else if (!masksMatch && hasMwMask) {
        syncStatusEl.textContent = 'Clip needs update';
        syncStatusEl.className = 'needs-update';
      } else {
        syncStatusEl.textContent = '‚úì All synced';
        syncStatusEl.className = 'synced';
      }
    }
    
    function downloadCsv(mapId) {
      const gcps = window.allmapsGcpsData || [];
      if (gcps.length === 0) {
        alert('No GCPs to download');
        return;
      }
      
      const csv = 'x,y,lon,lat\n' + gcps.map(g => `${g.x},${g.y},${g.lon},${g.lat}`).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `allmaps-gcps-${mapId}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }
    
    function toggleExpand(btn) {
      const content = btn.parentElement.querySelector('.expandable-content');
      const isShown = content.classList.toggle('show');
      btn.textContent = isShown ? 'Hide' : 'Show';
      
      document.querySelectorAll('.expandable-content.show').forEach(el => {
        if (el !== content) {
          el.classList.remove('show');
          el.parentElement.querySelector('.btn-show').textContent = 'Show';
        }
      });
    }
    
    function copyText(id) {
      const textarea = document.getElementById(id);
      navigator.clipboard.writeText(textarea.value)
        .then(() => {
          const btn = textarea.parentElement.parentElement.querySelector('.btn-copy');
          const orig = btn.textContent;
          btn.textContent = '‚úì Copied!';
          setTimeout(() => btn.textContent = orig, 1500);
        })
        .catch(err => alert('Failed to copy: ' + err));
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.expandable')) {
        document.querySelectorAll('.expandable-content.show').forEach(el => {
          el.classList.remove('show');
          el.parentElement.querySelector('.btn-show').textContent = 'Show';
        });
      }
    });
  </script>
</body>
</html>
